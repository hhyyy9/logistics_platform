module logistics_platform::delivery_service {
    use std::string::{Self, String};
    use aptos_framework::coin::{Self, Coin};
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::account::{Self, SignerCapability};
    use aptos_framework::timestamp;
    use aptos_framework::event;
    use aptos_std::table::{Self, Table};
    use aptos_std::hash;
    use std::signer;
    use std::vector;
    use std::bcs;

    // Define the admin address as a constant
    const ADMIN_ADDRESS: address = @0x123; // Replace with the actual admin address


    // Define role constants
    const ROLE_UNASSIGNED: u8 = 0;
    const ROLE_PLATFORM_OWNER: u8 = 1;
    const ROLE_COURIER: u8 = 2;
    const ROLE_USER: u8 = 3;

    // Define order status constants
    const PENDING: u8 = 0;
    const IN_PROGRESS: u8 = 1;
    const COMPLETED: u8 = 2;
    const CANCELLED: u8 = 3;

    // Error codes
    const E_NOT_INITIALIZED: u64 = 1;
    const E_ALREADY_INITIALIZED: u64 = 2;
    const E_INVALID_ORDER_STATUS: u64 = 3;
    const E_INSUFFICIENT_RATING: u64 = 4;
    const E_INSUFFICIENT_COMPLETED_ORDERS: u64 = 5;
    const E_UNAUTHORIZED: u64 = 6;
    const E_INVALID_CONFIRMATION_CODE: u64 = 7;
    const E_ALREADY_REGISTERED: u64 = 8;
    const E_INVALID_ROLE: u64 = 9;
    const E_INSUFFICIENT_PLATFORM_BALANCE: u64 = 10;
    const E_ORDER_ALREADY_ACCEPTED: u64 = 11;
    const E_ORDER_NOT_COMPLETED: u64 = 12;
    const E_RATING_OUT_OF_RANGE: u64 = 13;
    const E_ORDER_EXPIRED: u64 = 14;
    const E_INVALID_COORDINATE: u64 = 15;
    const E_INVALID_FEE: u64 = 16;
    const E_INVALID_DEADLINE: u64 = 17;
    const E_BATCH_OPERATION_FAILED: u64 = 18;
    const E_NOT_ADMIN: u64 = 19;
    const E_INVALID_STATUS_TRANSITION: u64 = 20;
    const E_USER_DEACTIVATED: u64 = 21;
    const E_COURIER_DEACTIVATED: u64 = 22;

    // Coordinate structure
    struct Coordinate has copy, drop, store {
        latitude: u64,
        longitude: u64,
    }

    // Delivery order structure
    struct DeliveryOrder has store {
        order_id: u64,
        sender: address,
        recipient: address,
        courier: address,
        pickup_address: String,
        delivery_address: String,
        pickup_coordinate: Coordinate,
        delivery_coordinate: Coordinate,
        delivery_fee: u64,
        service_fee: u64,
        total_fee: u64,
        deadline: u64,
        min_rating: u8,
        min_completed_orders: u64,
        status: u8,
        confirmation_code: vector<u8>,
        created_at: u64,
    }

    // Courier structure
    struct Courier has store {
        address: address,
        email: String,
        rating: u64,
        total_ratings: u64,
        completed_orders: u64,
        is_active: bool,
    }

    // User structure
    struct User has store {
        address: address,
        email: String,
        is_active: bool,
    }

    // Platform statistics structure
    struct PlatformStats has store {
        total_orders: u64,
        completed_orders: u64,
        cancelled_orders: u64,
        total_delivery_fees: u64,
        total_service_fees: u64,
    }

    // Platform account structure
    struct PlatformAccount has key {
        orders: Table<u64, DeliveryOrder>,
        couriers: Table<address, Courier>,
        users: Table<address, User>,
        user_orders: Table<address, vector<u64>>,
        next_order_id: u64,
        service_fee_percentage: u64,
        roles: Table<address, u8>,
        signer_cap: SignerCapability,
        platform_balance: Coin<AptosCoin>,
        stats: PlatformStats,
    }

    // Event structures
    struct OrderCreatedEvent has drop, store {
        order_id: u64,
        sender: address,
        recipient: address,
        pickup_coordinate: Coordinate,
        delivery_coordinate: Coordinate,
        delivery_fee: u64,
        service_fee: u64,
        total_fee: u64,
        confirmation_code: vector<u8>,
    }

    struct DeliveryConfirmedEvent has drop, store {
        order_id: u64,
        courier: address,
        recipient: address,
        delivery_fee: u64,
        service_fee: u64,
    }

    struct OrderRatedEvent has drop, store {
        order_id: u64,
        courier: address,
        rating: u8,
    }

    // New event for order status update
    struct OrderStatusUpdatedEvent has drop, store {
        order_id: u64,
        old_status: u8,
        new_status: u8,
    }

    //event for user/courier update and deactivation
    struct UserUpdatedEvent has drop, store {
        user_address: address,
        new_email: String,
    }

    struct CourierUpdatedEvent has drop, store {
        courier_address: address,
        new_email: String,
    }

    struct UserDeactivatedEvent has drop, store {
        user_address: address,
    }

    struct CourierDeactivatedEvent has drop, store {
        courier_address: address,
    }

    struct OrderCancelledEvent has drop, store {
        order_id: u64,
        reason: String,
    }

    // Initialize the platform
    public entry fun initialize(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        assert!(admin_addr == ADMIN_ADDRESS, E_NOT_ADMIN);
        assert!(!exists<PlatformAccount>(admin_addr), E_ALREADY_INITIALIZED);

        let (resource_signer, resource_signer_cap) = account::create_resource_account(admin, vector::empty());
        let resource_signer_addr = signer::address_of(&resource_signer);

        let mut roles = table::new();
        table::add(&mut roles, admin_addr, ROLE_PLATFORM_OWNER);

        move_to(admin, PlatformAccount {
            orders: table::new(),
            couriers: table::new(),
            users: table::new(),
            user_orders: table::new(),
            next_order_id: 0,
            service_fee_percentage: 5, // 5% service fee
            roles,
            signer_cap: resource_signer_cap,
            platform_balance: coin::zero<AptosCoin>(),
            stats: PlatformStats {
                total_orders: 0,
                completed_orders: 0,
                cancelled_orders: 0,
                total_delivery_fees: 0,
                total_service_fees: 0,
            },
        });
    }

    // Register as a user
    public entry fun register_user(user: &signer, email: String) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let user_address = signer::address_of(user);
        
        assert!(!table::contains(&platform_account.roles, user_address), E_ALREADY_REGISTERED);
        
        let new_user = User {
            address: user_address,
            email,
            is_active: true,
        };
        
        table::add(&mut platform_account.users, user_address, new_user);
        table::add(&mut platform_account.roles, user_address, ROLE_USER);
    }

    // Create a delivery order
    public entry fun create_order(
        sender: &signer,
        recipient: address,
        pickup_address: String,
        delivery_address: String,
        pickup_latitude: u64,
        pickup_longitude: u64,
        delivery_latitude: u64,
        delivery_longitude: u64,
        delivery_fee: u64,
        deadline: u64,
        min_rating: u8,
        min_completed_orders: u64
    ) acquires PlatformAccount {
        let sender_address = signer::address_of(sender);
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        
        assert!(table::contains(&platform_account.users, sender_address), E_UNAUTHORIZED);
        assert!(table::contains(&platform_account.users, recipient), E_UNAUTHORIZED);
        
        let sender_info = table::borrow(&platform_account.users, sender_address);
        let recipient_info = table::borrow(&platform_account.users, recipient);
        assert!(sender_info.is_active, E_USER_DEACTIVATED);
        assert!(recipient_info.is_active, E_USER_DEACTIVATED);

        let order_id = platform_account.next_order_id;
        platform_account.next_order_id = order_id + 1;

        let service_fee = (delivery_fee * platform_account.service_fee_percentage) / 100;
        let total_fee = delivery_fee + service_fee;

        let confirmation_code = generate_confirmation_code(sender_address, recipient, order_id);

        let order = DeliveryOrder {
            order_id,
            sender: sender_address,
            recipient,
            courier: @0x0,
            pickup_address,
            delivery_address,
            pickup_coordinate: Coordinate { latitude: pickup_latitude, longitude: pickup_longitude },
            delivery_coordinate: Coordinate { latitude: delivery_latitude, longitude: delivery_longitude },
            delivery_fee,
            service_fee,
            total_fee,
            deadline,
            min_rating,
            min_completed_orders,
            status: PENDING,
            confirmation_code,
            created_at: timestamp::now_seconds(),
        };

        table::add(&mut platform_account.orders, order_id, order);

        // Add order to user's order list
        if (!table::contains(&platform_account.user_orders, sender_address)) {
            table::add(&mut platform_account.user_orders, sender_address, vector::empty<u64>());
        };
        let user_orders = table::borrow_mut(&mut platform_account.user_orders, sender_address);
        vector::push_back(user_orders, order_id);

        let coins = coin::withdraw<AptosCoin>(sender, total_fee);
        coin::deposit(signer::address_of(&account::create_signer_with_capability(&platform_account.signer_cap)), coins);

        // Update stats
        platform_account.stats.total_orders = platform_account.stats.total_orders + 1;
        platform_account.stats.total_delivery_fees = platform_account.stats.total_delivery_fees + delivery_fee;
        platform_account.stats.total_service_fees = platform_account.stats.total_service_fees + service_fee;

        emit_order_created_event(order_id, sender_address, recipient, order.pickup_coordinate, order.delivery_coordinate, delivery_fee, service_fee, total_fee, confirmation_code);
    }

    // Accept an order by a courier
    public entry fun accept_order(courier: &signer, order_id: u64) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let courier_address = signer::address_of(courier);
        
        assert!(table::contains(&platform_account.roles, courier_address), E_UNAUTHORIZED);
        assert!(*table::borrow(&platform_account.roles, courier_address) == ROLE_COURIER, E_UNAUTHORIZED);
        
        let order = table::borrow_mut(&mut platform_account.orders, order_id);
        assert!(order.status == PENDING, E_INVALID_ORDER_STATUS);
        assert!(order.courier == @0x0, E_ORDER_ALREADY_ACCEPTED);
        
        let courier_info = table::borrow(&platform_account.couriers, courier_address);
        assert!(courier_info.rating / (courier_info.total_ratings + 1) >= (order.min_rating as u64), E_INSUFFICIENT_RATING);
        assert!(courier_info.completed_orders >= order.min_completed_orders, E_INSUFFICIENT_COMPLETED_ORDERS);
        
        order.courier = courier_address;
        order.status = IN_PROGRESS;
    }

    // Confirm delivery completion
    public entry fun confirm_delivery(recipient: &signer, order_id: u64, input_code: vector<u8>) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let order = table::borrow_mut(&mut platform_account.orders, order_id);
        
        assert!(signer::address_of(recipient) == order.recipient, E_UNAUTHORIZED);
        assert!(order.status == IN_PROGRESS, E_INVALID_ORDER_STATUS);
        assert!(order.confirmation_code == input_code, E_INVALID_CONFIRMATION_CODE);
        
        order.status = COMPLETED;
        
        let platform_signer = account::create_signer_with_capability(&platform_account.signer_cap);
        
        // Transfer delivery fee to courier
        let courier_payment = coin::withdraw<AptosCoin>(&platform_signer, order.delivery_fee);
        coin::deposit(order.courier, courier_payment);
        
        // Add service fee to platform balance
        let service_fee_payment = coin::withdraw<AptosCoin>(&platform_signer, order.service_fee);
        coin::merge(&mut platform_account.platform_balance, service_fee_payment);
        
        let courier = table::borrow_mut(&mut platform_account.couriers, order.courier);
        courier.completed_orders = courier.completed_orders + 1;
        
        // Update stats
        platform_account.stats.completed_orders = platform_account.stats.completed_orders + 1;
        
        emit_delivery_confirmed_event(order_id, order.courier, order.recipient, order.delivery_fee, order.service_fee);
    }

    // Register as a courier
    public entry fun register_courier(courier: &signer, email: String) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let courier_address = signer::address_of(courier);
        
        assert!(!table::contains(&platform_account.roles, courier_address), E_ALREADY_REGISTERED);
        
        let new_courier = Courier {
            address: courier_address,
            email,
            rating: 5, // Initial rating is 5 stars
            total_ratings: 1, // Start with 1 rating to avoid division by zero
            completed_orders: 0,
            is_active: true,
        };
        
        table::add(&mut platform_account.couriers, courier_address, new_courier);
        table::add(&mut platform_account.roles, courier_address, ROLE_COURIER);
    }

    // Cancel an order (can only be done by the sender if the order is still pending)
    public entry fun cancel_order(sender: &signer, order_id: u64) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let order = table::borrow_mut(&mut platform_account.orders, order_id);
        
        assert!(signer::address_of(sender) == order.sender, E_UNAUTHORIZED);
        assert!(order.status == PENDING, E_INVALID_ORDER_STATUS);
        
        order.status = CANCELLED;
        
        let platform_signer = account::create_signer_with_capability(&platform_account.signer_cap);
        let refund_amount = coin::withdraw<AptosCoin>(&platform_signer, order.total_fee);
        coin::deposit(order.sender, refund_amount);

        // Update stats
        platform_account.stats.cancelled_orders = platform_account.stats.cancelled_orders + 1;
        platform_account.stats.total_delivery_fees = platform_account.stats.total_delivery_fees - order.delivery_fee;
        platform_account.stats.total_service_fees = platform_account.stats.total_service_fees - order.service_fee;
    }

    // Update service fee percentage (only callable by the platform owner)
    public entry fun update_service_fee(platform_owner: &signer, new_percentage: u64) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let owner_address = signer::address_of(platform_owner);
        
        assert!(table::contains(&platform_account.roles, owner_address), E_UNAUTHORIZED);
        assert!(*table::borrow(&platform_account.roles, owner_address) == ROLE_PLATFORM_OWNER, E_UNAUTHORIZED);
        
        platform_account.service_fee_percentage = new_percentage;
    }

    // Withdraw platform fees (only for platform owner)
    public entry fun withdraw_platform_fees(platform_owner: &signer, amount: u64) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let owner_address = signer::address_of(platform_owner);
        
        assert!(table::contains(&platform_account.roles, owner_address), E_UNAUTHORIZED);
        assert!(*table::borrow(&platform_account.roles, owner_address) == ROLE_PLATFORM_OWNER, E_UNAUTHORIZED);
        assert!(coin::value(&platform_account.platform_balance) >= amount, E_INSUFFICIENT_PLATFORM_BALANCE);
        
        let withdraw_coins = coin::extract(&mut platform_account.platform_balance, amount);
        coin::deposit(owner_address, withdraw_coins);
    }

    // Rate an order (can be done by sender or recipient after order completion)
    public entry fun rate_order(user: &signer, order_id: u64, rating: u8) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let order = table::borrow(&platform_account.orders, order_id);
        
        assert!(signer::address_of(user) == order.sender || signer::address_of(user) == order.recipient, E_UNAUTHORIZED);
        assert!(order.status == COMPLETED, E_ORDER_NOT_COMPLETED);
        assert!(rating >= 1 && rating <= 5, E_RATING_OUT_OF_RANGE);

        let courier = table::borrow_mut(&mut platform_account.couriers, order.courier);
        courier.rating = courier.rating + (rating as u64);
        courier.total_ratings = courier.total_ratings + 1;

        event::emit(OrderRatedEvent {
            order_id,
            courier: order.courier,
            rating,
        });
    }

    // Check and cancel expired orders (only callable by platform owner)
    public entry fun check_and_cancel_expired_orders(platform_owner: &signer) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let owner_address = signer::address_of(platform_owner);
        
        assert!(table::contains(&platform_account.roles, owner_address), E_UNAUTHORIZED);
        assert!(*table::borrow(&platform_account.roles, owner_address) == ROLE_PLATFORM_OWNER, E_UNAUTHORIZED);

        let current_time = timestamp::now_seconds();

        let i = 0;
        while (i < platform_account.next_order_id) {
            if (table::contains(&platform_account.orders, i)) {
                let order = table::borrow_mut(&mut platform_account.orders, i);
                if (order.status == PENDING && current_time > order.deadline) {
                    order.status = CANCELLED;

                    let platform_signer = account::create_signer_with_capability(&platform_account.signer_cap);
                    let refund_amount = coin::withdraw<AptosCoin>(&platform_signer, order.total_fee);
                    coin::deposit(order.sender, refund_amount);

                    // Update stats
                    platform_account.stats.cancelled_orders = platform_account.stats.cancelled_orders + 1;
                    platform_account.stats.total_delivery_fees = platform_account.stats.total_delivery_fees - order.delivery_fee;
                    platform_account.stats.total_service_fees = platform_account.stats.total_service_fees - order.service_fee;
                };
            };
            i = i + 1;
        };
    }

    // Get courier details
    public fun get_courier_details(courier_address: address): (String, u64, u64, u64) acquires PlatformAccount {
        let platform_account = borrow_global<PlatformAccount>(@logistics_platform);
        let courier = table::borrow(&platform_account.couriers, courier_address);
        
        (courier.email, courier.rating / (courier.total_ratings + 1), courier.total_ratings, courier.completed_orders)
    }

    // Get order details
    public fun get_order_details(order_id: u64): (address, address, address, String, String, Coordinate, Coordinate, u64, u64, u64, u8) acquires PlatformAccount {
        let platform_account = borrow_global<PlatformAccount>(@logistics_platform);
        let order = table::borrow(&platform_account.orders, order_id);
        
        (order.sender, order.recipient, order.courier, order.pickup_address, order.delivery_address, 
         order.pickup_coordinate, order.delivery_coordinate, order.delivery_fee, order.service_fee, 
         order.total_fee, order.status)
    }

    // Get user's orders
    public fun get_user_orders(user_address: address): vector<u64> acquires PlatformAccount {
        let platform_account = borrow_global<PlatformAccount>(@logistics_platform);
        if (table::contains(&platform_account.user_orders, user_address)) {
            *table::borrow(&platform_account.user_orders, user_address)
        } else {
            vector::empty<u64>()
        }
    }

    // Get platform statistics
    public fun get_platform_stats(): (u64, u64, u64, u64, u64) acquires PlatformAccount {
        let platform_account = borrow_global<PlatformAccount>(@logistics_platform);
        let stats = &platform_account.stats;
        (
            stats.total_orders,
            stats.completed_orders,
            stats.cancelled_orders,
            stats.total_delivery_fees,
            stats.total_service_fees
        )
    }

    // Helper function to generate confirmation code
    fun generate_confirmation_code(sender: address, recipient: address, order_id: u64): vector<u8> {
        let mut input = vector::empty<u8>();
        vector::append(&mut input, bcs::to_bytes(&sender));
        vector::append(&mut input, bcs::to_bytes(&recipient));
        vector::append(&mut input, bcs::to_bytes(&order_id));
        vector::append(&mut input, bcs::to_bytes(&timestamp::now_microseconds()));
        
        hash::sha3_256(input)
    }

    // Helper function to emit order created event
    fun emit_order_created_event(
        order_id: u64,
        sender: address,
        recipient: address,
        pickup_coordinate: Coordinate,
        delivery_coordinate: Coordinate,
        delivery_fee: u64,
        service_fee: u64,
        total_fee: u64,
        confirmation_code: vector<u8>
    ) {
        event::emit(OrderCreatedEvent {
            order_id,
            sender,
            recipient,
            pickup_coordinate,
            delivery_coordinate,
            delivery_fee,
            service_fee,
            total_fee,
            confirmation_code,
        });
    }

    // Helper function to emit delivery confirmed event
    fun emit_delivery_confirmed_event(
        order_id: u64,
        courier: address,
        recipient: address,
        delivery_fee: u64,
        service_fee: u64
    ) {
        event::emit(DeliveryConfirmedEvent {
            order_id,
            courier,
            recipient,
            delivery_fee,
            service_fee,
        });
    }

    // update order status
    public entry fun update_order_status(
        authorized_user: &signer,
        order_id: u64,
        new_status: u8
    ) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let order = table::borrow_mut(&mut platform_account.orders, order_id);
        let user_address = signer::address_of(authorized_user);
        
        assert!(
            (new_status == IN_PROGRESS && user_address == order.courier) ||
            (new_status == COMPLETED && user_address == order.recipient) ||
            (new_status == CANCELLED && (user_address == order.sender || has_platform_owner_role(user_address, platform_account))),
            E_UNAUTHORIZED
        );
        
        // Check for valid status transitions
        assert!(
            (order.status == PENDING && new_status == IN_PROGRESS) ||
            (order.status == IN_PROGRESS && (new_status == COMPLETED || new_status == CANCELLED)) ||
            (order.status == PENDING && new_status == CANCELLED),
            E_INVALID_STATUS_TRANSITION
        );
        
        let old_status = order.status;
        order.status = new_status;
        
        if (new_status == COMPLETED) {
            handle_order_completion(platform_account, order);
        } else if (new_status == CANCELLED) {
            handle_order_cancellation(platform_account, order);
            
            // Emit OrderCancelledEvent
            event::emit(OrderCancelledEvent {
                order_id,
                reason: if (user_address == order.sender) {
                    string::utf8(b"Cancelled by sender")
                } else {
                    string::utf8(b"Cancelled by platform")
                },
            });
        }
        
        event::emit(OrderStatusUpdatedEvent {
            order_id,
            old_status,
            new_status,
        });
    }

    // Helper function to handle order completion
    fun handle_order_completion(platform_account: &mut PlatformAccount, order: &DeliveryOrder) {
        let platform_signer = account::create_signer_with_capability(&platform_account.signer_cap);
        
        // Transfer delivery fee to courier
        let courier_payment = coin::withdraw<AptosCoin>(&platform_signer, order.delivery_fee);
        coin::deposit(order.courier, courier_payment);
        
        // Add service fee to platform balance
        let service_fee_payment = coin::withdraw<AptosCoin>(&platform_signer, order.service_fee);
        coin::merge(&mut platform_account.platform_balance, service_fee_payment);
        
        let courier = table::borrow_mut(&mut platform_account.couriers, order.courier);
        courier.completed_orders = courier.completed_orders + 1;
        
        // Update stats
        platform_account.stats.completed_orders = platform_account.stats.completed_orders + 1;
    }

    // Helper function to handle order cancellation
    fun handle_order_cancellation(platform_account: &mut PlatformAccount, order: &DeliveryOrder) {
        let platform_signer = account::create_signer_with_capability(&platform_account.signer_cap);
        let refund_amount = coin::withdraw<AptosCoin>(&platform_signer, order.total_fee);
        coin::deposit(order.sender, refund_amount);

        // Update stats
        platform_account.stats.cancelled_orders = platform_account.stats.cancelled_orders + 1;
        platform_account.stats.total_delivery_fees = platform_account.stats.total_delivery_fees - order.delivery_fee;
        platform_account.stats.total_service_fees = platform_account.stats.total_service_fees - order.service_fee;
    }

    // Function to get platform balance
    public fun get_platform_balance(): u64 acquires PlatformAccount {
        let platform_account = borrow_global<PlatformAccount>(@logistics_platform);
        coin::value(&platform_account.platform_balance)
    }

    // Helper function to check if an address has platform owner role
    fun has_platform_owner_role(addr: address, platform_account: &PlatformAccount): bool {
        table::contains(&platform_account.roles, addr) &&
        *table::borrow(&platform_account.roles, addr) == ROLE_PLATFORM_OWNER
    }

    // function to update user information
    public entry fun update_user_info(user: &signer, new_email: String) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let user_address = signer::address_of(user);
        
        assert!(table::contains(&platform_account.users, user_address), E_UNAUTHORIZED);
        let user_info = table::borrow_mut(&mut platform_account.users, user_address);
        assert!(user_info.is_active, E_USER_DEACTIVATED);
        
        user_info.email = new_email;

        event::emit(UserUpdatedEvent {
            user_address,
            new_email,
        });
    }

    // function to deactivate a user
    public entry fun deactivate_user(admin: &signer, user_address: address) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let admin_address = signer::address_of(admin);
        
        assert!(has_platform_owner_role(admin_address, platform_account), E_UNAUTHORIZED);
        assert!(table::contains(&platform_account.users, user_address), E_UNAUTHORIZED);
        
        let user_info = table::borrow_mut(&mut platform_account.users, user_address);
        user_info.is_active = false;

        event::emit(UserDeactivatedEvent {
            user_address,
        });
    }

    // Function to update courier information
    public entry fun update_courier_info(courier: &signer, new_email: String) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let courier_address = signer::address_of(courier);
        
        assert!(table::contains(&platform_account.couriers, courier_address), E_UNAUTHORIZED);
        let courier_info = table::borrow_mut(&mut platform_account.couriers, courier_address);
        assert!(courier_info.is_active, E_COURIER_DEACTIVATED);
        
        courier_info.email = new_email;

        event::emit(CourierUpdatedEvent {
            courier_address,
            new_email,
        });
    }

    // Function to deactivate a courier
    public entry fun deactivate_courier(admin: &signer, courier_address: address) acquires PlatformAccount {
        let platform_account = borrow_global_mut<PlatformAccount>(@logistics_platform);
        let admin_address = signer::address_of(admin);
        
        assert!(has_platform_owner_role(admin_address, platform_account), E_UNAUTHORIZED);
        assert!(table::contains(&platform_account.couriers, courier_address), E_UNAUTHORIZED);
        
        let courier_info = table::borrow_mut(&mut platform_account.couriers, courier_address);
        courier_info.is_active = false;

        event::emit(CourierDeactivatedEvent {
            courier_address,
        });
    }
    
}